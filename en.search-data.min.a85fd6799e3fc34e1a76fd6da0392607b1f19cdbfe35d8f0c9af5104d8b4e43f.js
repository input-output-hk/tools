'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/tools/docs/cross-compiler-test-suite/','title':"Cross Compiler Test Suite",'content':"Cross Compiler Test Suite The GHC Test Suite contains a large variety of tests, often distilled from bugreports. This testsuite is quite valuable, and is a requirement when merging new code into GHC. However the Test Suite has no concept of cross compilation and as such cross compiler mostly fly blind. We are therefore adding logic to the existing GHC Test Suite to also be able to run against Cross Compilers, and verify their behaviour.\n"});index.add({'id':1,'href':'/tools/docs/extensible-interface-files/','title':"Extensible Interface Files",'content':"Extensible Interface Files GHC tooling in general knows about two build artifacts when compiling haskell code this is object code contained in the .o files, as well as meta information contained in the .hi files. The information that\u0026rsquo;s contained in .hi files is primarily used to inlines code that was marked as INLINABLE, and for type information about exported symbols.\nExtensible Interface Files allows us to embed arbitrary extra data encoded by a key into .hi files. We want this for plutus, where the plutus compiler needs the core (one of GHC internal representations) representation of the haskell functions to properly translate a plutus program. This is currently done by forcing GHC to include the represenations using a few specific compilier flags. Extensible Interface Files provides this with a solid foundation, and we are currently in the process of moving the plutus compiler to use the Extensible Interface Files.\n"});index.add({'id':2,'href':'/tools/docs/ghcjs-foreign-export/','title':"Ghcjs Foreign Export",'content':"Foreign Export for GHCJS To consume GHCJS libraries in vanilla JS (or Type Script), it would be highly valuable if we could have proper foreign exports for GHCJS (and Asterius), as this would allow other libraries to consume cross compiled haskell libraries.\n"});index.add({'id':3,'href':'/tools/docs/haskell-nix/','title':"Haskell Nix",'content':"Haskell.nix haskell.nix is a haskell build infrastructure for nix. Nix provides reproducable builds, and haskell.nix provides the cabal/stack glue code to make nix aware of haskell projects. We use this to great success, and the tools team keeps improving and maintaining it. Part of the work the tools team does includes figuring out how to make ghc and cabal more friendly towards nix, such that we can reduce the complexity that is in haskell.nix.\n"});index.add({'id':4,'href':'/tools/docs/plutus-devcontainer/','title':"Plutus Devcontainer",'content':"Plutus Development Container The tools team works on a full IDE integration for Plutus. This work is split between the plutus and the tools team. The current focus is on getting ghcide to work nicely with plugins (as the plutus compiler is conceptually a plugin), and have this all contained in a docker container, which can drive a Vistual Studio Code instance. Or any other remote capable editor with a Language Server client implementation.\nEventually we want to provide a user friendly option for haskell.nix in the devcontainer as well, as it will be imperative for plutus contracts to be reproducable, and haskell.nix would provide us with the necessary infrastructure.\n"});index.add({'id':5,'href':'/tools/docs/rust-cross-compilation/','title':"Rust Cross Compilation",'content':"Rust Cross Compilation Rust\u0026ndash;by virtue of being a LLVM based compiler\u0026ndash;obtains most of the necessary infrastructure to be multiple target aware out of the box. However building rust in CI (especially in a nix based CI) can lead to compliations. This is very visible when trying to cross compile to Windows.\nWe\u0026rsquo;ve adopted an existing cargo wrapper for nix called naersk, and extended it to cover cross compilation and subsequently trivial integration of rust libraries into haskell applications. The code can be found in rust.nix.\n"});index.add({'id':6,'href':'/tools/docs/unboxed-tuples/','title':"Unboxed Tuples",'content':"Unboxed Tuples GHC\u0026rsquo;s Interpreter (which is also used in ghcide), has a severe limitation around unboxed tuples. These simply cannot be used with the interpreter unless one falls back to using object-code, which in turn doesn\u0026rsquo;t work with ghcide properly.\nWe are trying to make the GHC Interpreter Unboxed Tuple aware, which should improve ghcide performance and thus allow us to load large plutus programs (even the whole plutus repository into ghcide).\n"});index.add({'id':7,'href':'/tools/docs/windows-cross-compilation/','title':"Windows Cross Compilation",'content':"Windows Cross Compilation Building applications on windows in Continuous Integration (CI) can be a rather tricky endeavour. Especially if all the existing CI infrastructure is primarily linux based. For macOS, we can mostly treat it like linux, mostly. For Windows, not so much. Furthermore obtaining server licenses and the additional costs associated with windows servers can be annoying to manage, especially if only required in short burts. Thus it is qutie attractive to build Windows applications on non-windows machines.\nWe have extended GHC to be able to properly cross compile all of IOHKs haskell sourcecode to Windows.\n"});index.add({'id':8,'href':'/tools/docs/','title':"Docs",'content':""});})();