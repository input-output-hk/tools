<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on Loony Tools Team</title><link>https://input-output-hk.github.io/tools/docs/</link><description>Recent content in Docs on Loony Tools Team</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://input-output-hk.github.io/tools/docs/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://input-output-hk.github.io/tools/docs/cross-compiler-test-suite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://input-output-hk.github.io/tools/docs/cross-compiler-test-suite/</guid><description>Cross Compiler Test Suite The GHC Test Suite contains a large variety of tests, often distilled from bugreports. This testsuite is quite valuable, and is a requirement when merging new code into GHC. However the Test Suite has no concept of cross compilation and as such cross compiler mostly fly blind. We are therefore adding logic to the existing GHC Test Suite to also be able to run against Cross Compilers, and verify their behaviour.</description></item><item><title/><link>https://input-output-hk.github.io/tools/docs/extensible-interface-files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://input-output-hk.github.io/tools/docs/extensible-interface-files/</guid><description>Extensible Interface Files GHC tooling in general knows about two build artifacts when compiling haskell code this is object code contained in the .o files, as well as meta information contained in the .hi files. The information that&amp;rsquo;s contained in .hi files is primarily used to inlines code that was marked as INLINABLE, and for type information about exported symbols.
Extensible Interface Files allows us to embed arbitrary extra data encoded by a key into .</description></item><item><title/><link>https://input-output-hk.github.io/tools/docs/ghcjs-foreign-export/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://input-output-hk.github.io/tools/docs/ghcjs-foreign-export/</guid><description>Foreign Export for GHCJS To consume GHCJS libraries in vanilla JS (or Type Script), it would be highly valuable if we could have proper foreign exports for GHCJS (and Asterius), as this would allow other libraries to consume cross compiled haskell libraries.</description></item><item><title/><link>https://input-output-hk.github.io/tools/docs/haskell-nix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://input-output-hk.github.io/tools/docs/haskell-nix/</guid><description>Haskell.nix haskell.nix is a haskell build infrastructure for nix. Nix provides reproducable builds, and haskell.nix provides the cabal/stack glue code to make nix aware of haskell projects. We use this to great success, and the tools team keeps improving and maintaining it. Part of the work the tools team does includes figuring out how to make ghc and cabal more friendly towards nix, such that we can reduce the complexity that is in haskell.</description></item><item><title/><link>https://input-output-hk.github.io/tools/docs/plutus-devcontainer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://input-output-hk.github.io/tools/docs/plutus-devcontainer/</guid><description>Plutus Development Container The tools team works on a full IDE integration for Plutus. This work is split between the plutus and the tools team. The current focus is on getting ghcide to work nicely with plugins (as the plutus compiler is conceptually a plugin), and have this all contained in a docker container, which can drive a Vistual Studio Code instance. Or any other remote capable editor with a Language Server client implementation.</description></item><item><title/><link>https://input-output-hk.github.io/tools/docs/rust-cross-compilation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://input-output-hk.github.io/tools/docs/rust-cross-compilation/</guid><description>Rust Cross Compilation Rust&amp;ndash;by virtue of being a LLVM based compiler&amp;ndash;obtains most of the necessary infrastructure to be multiple target aware out of the box. However building rust in CI (especially in a nix based CI) can lead to compliations. This is very visible when trying to cross compile to Windows.
We&amp;rsquo;ve adopted an existing cargo wrapper for nix called naersk, and extended it to cover cross compilation and subsequently trivial integration of rust libraries into haskell applications.</description></item><item><title/><link>https://input-output-hk.github.io/tools/docs/unboxed-tuples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://input-output-hk.github.io/tools/docs/unboxed-tuples/</guid><description>Unboxed Tuples GHC&amp;rsquo;s Interpreter (which is also used in ghcide), has a severe limitation around unboxed tuples. These simply cannot be used with the interpreter unless one falls back to using object-code, which in turn doesn&amp;rsquo;t work with ghcide properly.
We are trying to make the GHC Interpreter Unboxed Tuple aware, which should improve ghcide performance and thus allow us to load large plutus programs (even the whole plutus repository into ghcide).</description></item><item><title/><link>https://input-output-hk.github.io/tools/docs/windows-cross-compilation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://input-output-hk.github.io/tools/docs/windows-cross-compilation/</guid><description>Windows Cross Compilation Building applications on windows in Continuous Integration (CI) can be a rather tricky endeavour. Especially if all the existing CI infrastructure is primarily linux based. For macOS, we can mostly treat it like linux, mostly. For Windows, not so much. Furthermore obtaining server licenses and the additional costs associated with windows servers can be annoying to manage, especially if only required in short burts. Thus it is qutie attractive to build Windows applications on non-windows machines.</description></item></channel></rss>